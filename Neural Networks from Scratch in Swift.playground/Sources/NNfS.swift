import GameKit

extension Array {
    /// Create a new Array whose values are generated by the given closure.
    /// - Parameters:
    ///     - count:            The number of elements to generate
    ///     - elementGenerator: The closure that generates the elements.
    ///                         The index into which the element will be
    ///                         inserted is passed into the closure.
    public init(count: Int, generating elementGenerator: (Int) -> Element) {
        self = (0..<count).map(elementGenerator)
    }
}

public class NNfS {
    static public let rs = GKLinearCongruentialRandomSource(seed: 0)
    static public let rd = GKGaussianDistribution(randomSource: rs, mean: 0, deviation: Float(UInt8.max))

    // https://cs231n.github.io/neural-networks-case-study/
    static public func spiral_data(points:Int, classes:Int) -> ([[Double]], [UInt8]) {
        let height = points * classes
        var X:[[Double]] = [[Double]](count: height, generating: { _ in [Double](repeating: 0.0, count: 2) })
        var y:[UInt8] = [UInt8](repeating: 0, count: points*classes)
        
        for classNumber in 0..<classes {
            let ix = points*classNumber..<points*(classNumber+1)

            let r = Array(count: points, generating: { n in Double(n)/Double(points) }) // radius
                        
            let tl = Array(count: points, generating: { n in Double(n)/Double(points) * 4.0 + Double(classNumber) })
            let tr = Array(count: points, generating: { _ in Double(rd.nextUniform()) * 0.2 })
            let t = tl.add(tr)!
                                    
            let rSin:[Double] = r.mul(sin(radians: t.mul(2.5)))!
            let rCos:[Double] = r.mul(cos(radians: t.mul(2.5)))!
            let xSub = rSin.concatHorizontal(rCos)
                        
            X.replaceSubrange(  ix, with: xSub )
            y.replaceSubrange(  ix, with: Array<UInt8>(repeating: UInt8(classNumber), count: ix.count) )
        }

        return (X, y)
    }
}
